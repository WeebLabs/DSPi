# Quality Control Report

**Date**: 2026-01-31
**Reviewed**: RP2350 Float Pipeline Port (config.h, dsp_pipeline.c/h, usb_audio.c/h, flash_storage.c, main.c, pdm_generator.c/h)
**Verdict**: APPROVED WITH CONDITIONS

## Executive Summary

The RP2350 port implements a well-structured dual-architecture approach with float processing on RP2350 and Q28 fixed-point on RP2040. The conditional compilation is mostly correct, but there are several issues: a critical peak metering inconsistency that will cause dramatically different behavior between platforms, a potential numeric overflow in PDM sample conversion, and missing clipping protection on the RP2350 path. The code is generally well-organized but requires targeted fixes before production deployment.

## Quality Score

| Dimension | Score | Notes |
|-----------|-------|-------|
| Correctness | 6/10 | Peak metering bug, potential PDM overflow, Taylor series approximation inaccuracy |
| Architecture | 8/10 | Clean separation via conditional compilation, consistent abstraction |
| Readability | 7/10 | Good structure but some magic numbers and dense inline math |
| Performance | 8/10 | Appropriate use of hardware FPU/DCP, efficient loop structure |
| Security | 9/10 | Input validation present, no obvious vulnerabilities in audio path |
| Testing | N/A | Pre-testing review - no tests to evaluate |
| **Overall** | **7/10** | Solid port with targeted fixes needed |

## Critical Issues

### 1. Peak Metering Produces Wildly Different Values Between Platforms

**Files**: `/Users/weeblabs/DSPi/firmware/foxdac/usb_audio.c` (lines 250-256 vs 340-344)

**Problem**: The RP2350 and RP2040 paths produce peak meter values with completely different scaling:

**RP2040 (lines 340-344)**:
```c
global_status.peaks[0] = (uint16_t)(peak_ml >> 13);
// peak_ml is in Q14 format (16-bit << 14), so >>13 gives 17-bit range values
// A full-scale signal: 32767 << 14 = 536,805,376 >> 13 = 65536 (overflows uint16!)
```

**RP2350 (lines 250-256)**:
```c
global_status.peaks[0] = (uint16_t)(peak_ml * 4.0f);
// peak_ml is normalized float [0.0, 1.0+], so *4 gives [0, 4+]
// A full-scale signal: 1.0 * 4.0 = 4
```

**Consequence**:
- RP2040 at 0dBFS reports ~65536 (wraps to 0 due to uint16 overflow)
- RP2350 at 0dBFS reports 4
- Client software cannot interpret meter values correctly

**Recommendation**: Both platforms should produce compatible peak values. Suggested fix for RP2350:
```c
global_status.peaks[0] = (uint16_t)(fminf(peak_ml, 4.0f) * 8191.0f);  // 0dBFS = 8191
```
And for RP2040, add saturation to prevent overflow.

---

### 2. PDM Output Conversion May Overflow for RP2350

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/usb_audio.c` (line 245)

**Problem**:
```c
int32_t sub_out = (int32_t)(fmaxf(-1.0f, fminf(1.0f, delayed_sub)) * 536870912.0f);
```

The scaling factor 536870912.0f (2^29) is correct, but this line depends on prior clipping to [-1, 1]. If any floating-point rounding or FPU precision error causes the value to be slightly above 1.0 before `fminf`, the result is still correct. However, the PDM generator expects input with:
```c
int32_t pcm_val = (sample_value >> 14);  // pdm_generator.c:169
```

536870912 >> 14 = 32768, which is within int16 range. This is correct.

**Actual Issue**: The comment says "PDM expects int32 where >>14 gives 16-bit range (i.e., Q14 format)" but the calculation uses 2^29. Let me verify:
- RP2040: `delayed_sub` is in Q14 format already (16-bit << 14), passed directly
- RP2350: `delayed_sub` is normalized [-1, 1] float, scaled by 2^29

RP2040: 32767 (full scale 16-bit) is passed as-is (already Q14 from processing)
RP2350: 1.0 * 536870912 = 536870912

Wait, this IS a bug. RP2040 doesn't shift to Q14 in the PDM push:
```c
// RP2040 path (line 336)
pdm_push_sample(delayed_sub, false);  // delayed_sub is already Q14
```

But RP2040's `delayed_sub` after volume:
```c
out_sub_32 = (int32_t)(((int64_t)out_sub_32 * vol_mul) >> 15);  // line 312
```

Actually, tracing through: input is 16-bit << 14 = Q14, then volume (* vol_mul >> 15) keeps it roughly Q14. So RP2040 passes Q14 to PDM.

RP2350 passes `1.0 * 536870912 = 536870912` for full scale. In PDM: `536870912 >> 14 = 32768`.

So both platforms pass equivalent values. **This is NOT a bug** - the comment is slightly misleading but the math is correct.

---

### 3. Potential Integer Overflow in RP2040 Peak Metering

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/usb_audio.c` (lines 286-287, 305-307, 340-344)

**Problem**:
```c
if (abs(master_l_32) > peak_ml) peak_ml = abs(master_l_32);
// ...
global_status.peaks[0] = (uint16_t)(peak_ml >> 13);
```

`abs()` on an `int32_t` value of `INT32_MIN` returns `INT32_MIN` (undefined behavior on some platforms, implementation-defined on others). While audio signals are unlikely to hit exactly INT32_MIN, this is a latent bug.

Additionally, if `peak_ml` is close to INT32_MAX (legitimate audio near clipping), `peak_ml >> 13` can exceed UINT16_MAX (65535):
- Max value: 2147483647 >> 13 = 261,983 (overflows uint16_t)

**Severity**: CRITICAL - overflow causes wrap-around to incorrect values.

**Recommendation**: Add saturation before cast:
```c
uint32_t shifted = (uint32_t)peak_ml >> 13;
if (shifted > 65535) shifted = 65535;
global_status.peaks[0] = (uint16_t)shifted;
```

---

## Major Issues

### 4. Taylor Series Approximation for dB-to-Linear Conversion is Inaccurate

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/flash_storage.c` (lines 145-156, 172-180)

**Problem**:
```c
// 10^(db/20) = e^(db * ln(10) / 20) = e^(db * 0.1151)
float x = db * 0.1151292546f;  // ln(10)/20
// Taylor series for e^x (good enough for our range)
linear = 1.0f + x + x*x*0.5f + x*x*x*0.1666667f + x*x*x*x*0.0416667f;
```

For -60dB: x = -60 * 0.1151 = -6.91
Taylor series with 4 terms diverges badly for |x| > 2:
- Actual: e^(-6.91) = 0.001
- Taylor: 1 - 6.91 + 23.9 - 55.0 + 95.0 = 58.0 (wrong by 58,000x!)

The comment says "good enough for our range" but the range is claimed to be -60 to +20 dB, which definitely exceeds Taylor series convergence.

**Consequence**: Loading saved parameters with gain < -17dB or > +8dB will produce incorrect multipliers.

**Recommendation**: Use `powf()` directly. The comment about "powf dependency issues" is unclear - `powf` is standard C and available on both platforms:
```c
linear = powf(10.0f, db / 20.0f);
```

---

### 5. Flat Filter Bypass Logic Incorrect

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/dsp_pipeline.c` (lines 161-162, 181)

**Problem**:
```c
// Skip flat/bypassed filters (a1=a2=0 means unity gain passthrough)
if (bq->a1 == 0.0f && bq->a2 == 0.0f) continue;
```

This comment and check are incorrect. For a FLAT filter:
```c
bq->b0 = 1.0f; bq->b1 = 0.0f; bq->b2 = 0.0f; bq->a1 = 0.0f; bq->a2 = 0.0f;
```

The check `a1 == 0 && a2 == 0` correctly identifies flat filters, BUT it also matches ANY filter where both feedback coefficients happen to be zero (though this is unlikely for standard audio filters).

More importantly, this optimization skips processing entirely, which is correct for flat filters but the sample passes through unchanged. The logic IS correct - the issue is just the misleading comment.

**Actual Issue**: For RP2040 path (line 181):
```c
if (bq->a1 == 0 && bq->a2 == 0) continue;
```

This compares int32_t to 0, which works. However, floating-point equality comparison (RP2350 path) is fragile. If coefficient computation produces a very small non-zero value due to floating-point precision, the filter won't be bypassed.

**Recommendation**: Use a small epsilon for float comparison:
```c
if (fabsf(bq->a1) < 1e-9f && fabsf(bq->a2) < 1e-9f) continue;
```

---

### 6. Missing Clipping Protection in RP2350 DSP Path

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/dsp_pipeline.c` (lines 155-172)

**Problem**: The RP2350 `dsp_process_channel` function returns the filter output without clipping:
```c
sample = (float)result;
// ...
return sample;
```

While float has enormous dynamic range, this means the processing chain can produce values far outside [-1, 1]. The final output IS clipped at lines 238-239:
```c
out[i*2] = (int16_t)(fmaxf(-1.0f, fminf(1.0f, delayed_l)) * 32767.0f);
```

However, intermediate values can grow unbounded through multiple high-gain EQ stages, potentially causing:
1. Numerical instability (though double-precision state mitigates this)
2. Unexpected behavior if intermediate values are used elsewhere

**Contrast with RP2040** (line 187):
```c
sample = clip_s32(result);
```

**Recommendation**: Consider adding soft clipping or at least warning-level monitoring for values exceeding [-2, 2] to catch configuration errors.

---

### 7. Volatile Access Pattern in Audio Callback May Cause Tearing

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/usb_audio.c` (lines 165-166, 260-261)

**Problem**:
```c
float preamp = global_preamp_mul;  // Read volatile into local
```

This is correct for single-use, but `channel_gain_mul[3]` is accessed inside the loop:
```c
out_l = channel_mute[0] ? 0.0f : out_l * channel_gain_mul[0];
```

On RP2350, `channel_gain_mul[0]` is a `volatile float`. Reading a volatile float may not be atomic on ARM (32-bit load is atomic, but float register operations may not be). If Core 0's main loop updates `channel_gain_mul` while the audio callback is running, the callback could see a partially-updated value.

**Likelihood**: Low, since the main loop updates these rarely and the timing window is small.

**Recommendation**: Copy volatile multipliers to locals before the loop, similar to how `preamp` is handled.

---

### 8. Flash Version Mismatch Could Lose Channel Gain Settings

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/flash_storage.c` (lines 126-128, 169-189)

**Problem**:
```c
// Check version (for future compatibility)
if (storage->version > FLASH_VERSION) {
    return FLASH_ERR_NO_DATA;  // Newer version, can't load
}
// ...
// V2: Per-channel gain and mute
if (storage->version >= 2) {
    // load channel gains
}
```

The check `storage->version > FLASH_VERSION` returns an error for newer versions, which is correct. However:

1. If an RP2350 (version 3) saves settings, then you downgrade to RP2040 (version 2), the load fails entirely. The user loses all settings including filter recipes.

2. The `if (storage->version >= 2)` check will be true for version 3, but version 3 (RP2350) data has different structure implications (10 bands per output channel vs 2).

**Consequence**: Cross-platform flash data is incompatible and fails silently in edge cases.

**Recommendation**: This is acceptable given the FLASH_VERSION differentiation, but add a comment explicitly stating that settings are NOT portable between RP2040 and RP2350.

---

## Minor Issues

### 9. Magic Number: 536870912.0f

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/usb_audio.c` (line 245)

**Problem**:
```c
int32_t sub_out = (int32_t)(fmaxf(-1.0f, fminf(1.0f, delayed_sub)) * 536870912.0f);
```

The value 536870912 = 2^29. This should be a named constant with a comment explaining the scaling relationship to the PDM generator's expectations.

---

### 10. Inconsistent Band Count Access

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/usb_audio.c` (lines 706-721)

**Problem**:
```c
if (channel < NUM_CHANNELS && band < channel_band_counts[channel]) {
```

The `channel_band_counts` array differs between platforms:
- RP2350: {10, 10, 10, 10, 10}
- RP2040: {10, 10, 2, 2, 2}

If a host application stores a band index assuming RP2350's 10 bands and then queries RP2040, the check will fail silently. This is expected behavior but should be documented.

---

### 11. `clip_s32` Function is Never Actually Useful

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/config.h` (lines 192-196)

**Problem**:
```c
static inline int32_t clip_s32(int32_t x) {
    if (x > INT32_MAX) return INT32_MAX;
    if (x < INT32_MIN) return INT32_MIN;
    return x;
}
```

This function is pointless - if `x` is `int32_t`, it can NEVER be greater than `INT32_MAX` or less than `INT32_MIN`. The comparisons are always false.

**Location of Actual Usage**: `usb_audio.c` lines 314-316, 331-332:
```c
out_l_32 = clip_s32(out_l_32);
```

This provides no protection. If overflow occurred during computation, it's already wrapped.

**Recommendation**: Either remove `clip_s32` and rely on `clip_s64_to_s32` exclusively, or rename to clarify its (lack of) purpose.

---

### 12. Unused `vendor_queue_response` Function

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/usb_audio.c` (lines 91-94)

**Problem**:
```c
bool vendor_queue_response(const VendorRespPacket *resp) {
    // Deprecated with Control-Only interface
    return false;
}
```

This function is declared in the header and defined but always returns false. It should be removed or the header declaration should be wrapped in a `#if 0` block.

---

### 13. Hardcoded 192 Sample Count in Silence Pre-fill

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/usb_audio.c` (lines 142-146)

**Problem**:
```c
for (uint32_t j = 0; j < 192; j++) {
    out[j * 2] = 0;
    out[j * 2 + 1] = 0;
}
sb->sample_count = 192;
```

The value 192 should use `AUDIO_BUFFER_SAMPLES` from config.h for consistency.

---

## Suggestions

### 14. Use `fabsf` Instead of `abs` for Peak Detection

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/usb_audio.c` (lines 286-287)

While `abs()` works on int32_t in practice, using the explicit integer absolute value function `labs()` would be more correct. Alternatively, define a macro:
```c
#define ABS_I32(x) ((x) >= 0 ? (x) : -(x))
```

---

### 15. Consider Atomic Operations for Cross-Core Status Updates

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/usb_audio.c` (lines 250-256), `pdm_generator.c` (line 214)

Both cores write to `global_status`:
- Core 0: peaks[0-4], cpu0_load
- Core 1: cpu1_load

While they write to different fields, the struct is packed and reads by USB host could see inconsistent data. Consider using atomic stores or double-buffering for the status struct.

---

### 16. Add Compile-Time Assertion for Biquad Struct Size

**File**: `/Users/weeblabs/DSPi/firmware/foxdac/config.h`

The comments claim specific sizes (36 bytes for RP2350, 28 bytes for RP2040). Add:
```c
#if PICO_RP2350
_Static_assert(sizeof(Biquad) == 36, "Biquad size mismatch");
#else
_Static_assert(sizeof(Biquad) == 28, "Biquad size mismatch");
#endif
```

---

## What Was Done Well

1. **Clean Conditional Compilation Structure**: The `#if PICO_RP2350 / #else` blocks are consistently placed and logically grouped. Each platform-specific section is complete and self-contained.

2. **Double-Precision State Accumulators on RP2350**: Using `double` for biquad state (`s1`, `s2`) while keeping coefficients as `float` is an excellent balance of precision and performance. This provides ~144dB SNR per stage.

3. **Transposed Direct Form II**: The biquad implementation uses the numerically stable transposed form, which is the correct choice for floating-point audio processing.

4. **Flash Version Differentiation**: Separating FLASH_VERSION between platforms (2 vs 3) prevents loading incompatible settings.

5. **Ring Buffer Design for PDM Cross-Core Communication**: The lock-free SPSC ring buffer with `__sev()` for wakeup is efficient and appropriate for the use case.

6. **Comprehensive Error Counters**: The separate counters for ring overruns/underruns, DMA overruns/underruns, and SPDIF overruns/underruns provide excellent observability.

7. **Delay Line Implementation**: The circular delay buffer with mask-based wrapping is efficient and correct.

8. **Pre-fill Strategy on Audio Restart**: Detecting gaps >50ms and pre-filling silent buffers prevents click artifacts on play/pause.

---

## Required Actions

1. **[CRITICAL]** Fix peak metering inconsistency between platforms - both should produce values in the same range for the same input level.

2. **[CRITICAL]** Add saturation to RP2040 peak meter shift to prevent uint16_t overflow.

3. **[MAJOR]** Replace Taylor series approximation in flash_storage.c with `powf()` for accurate dB-to-linear conversion.

4. **[MAJOR]** Copy volatile `channel_gain_mul` values to local variables before the audio processing loop.

5. **[MINOR]** Replace magic number 536870912.0f with named constant (e.g., `#define PDM_SCALE_FACTOR (1 << 29)`).

6. **[MINOR]** Replace hardcoded 192 with `AUDIO_BUFFER_SAMPLES` in silence pre-fill.

7. **[MINOR]** Remove or conditionally compile out unused `vendor_queue_response` function.

---

## Reviewer Notes

The overall architecture of this port is sound. The decision to use float on RP2350 with the hardware FPU and maintain Q28 fixed-point on RP2040 is appropriate given the hardware capabilities. The double-precision state accumulators on RP2350 provide excellent numerical stability.

The most concerning issues are the peak metering discrepancy and the Taylor series approximation. The former will cause UI meters to display incorrectly on RP2350 compared to RP2040, which will be immediately visible to users. The latter will cause stored presets with significant gain values to be recalled incorrectly after a power cycle.

Thread safety between Core 0 and Core 1 appears acceptable given the SPSC ring buffer design and the fact that each core writes to distinct memory locations. However, the volatile access pattern for gain multipliers during the audio loop deserves attention.

The code would benefit from a shared constants header for values like the PDM scale factor, and static assertions to catch any struct packing surprises across compiler versions.

---

*Reviewed by: Quality Control Engineer*
*Review Tool: Claude Opus 4.5*
